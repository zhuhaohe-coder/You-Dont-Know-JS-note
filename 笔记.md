# 作用域和闭包

## 1.作用域是什么

> 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。



> 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值, 否则引擎就会抛出一个异常

**JS引擎查找变量的方式: LHS和RHS**

LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“= 赋值操作符的左侧或右侧”。赋值操作还有其他几种形式

因此在概念上最 好将其理解为“==赋值操作的目标是谁（LHS）==”以及“==谁是赋值操作的源头 （RHS）==”

**小测验** 

检验一下到目前的理解程度。把自己当作引擎，并同作用域进行一次“对话”： 

```js
function foo(a) {
  var b = a; 
  return a + b; 
} 
var c = foo( 2 ); 
```

1. 找到其中所有的 LHS 查询。（这里有 3 处！）
   - c=foo(2)
   - a=2
   - b=a
2. 找到其中所有的 RHS 查询。（这里有 4 处！)
   - foo的声明
   - var b = a; a的值
   -  return a + b;  a的值
   -  return a + b;  b的值

> ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对 结果的操作是非法或不合理的。

## 2.词法作用域

> 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的 标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。
>
> 全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此 可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引 用来对其进行访问
>
> `window.a`
>
> 通过这种技术可以访问那些被同名变量所遮蔽的全局变量。**但非全局的变量 如果被遮蔽了，无论如何都无法被访问到。**

## 3.函数作用域

> 区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位 置（不仅仅是一行代码，而是整个声明中的位置）。**如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式。**

行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。始终给函数表达式命名是一个最佳实践

```js
setTimeout( function timeoutHandler() { // <-- 快看，我有名字了！
	console.log( "I waited 1 second!" );
}, 1000 );
```

