# 作用域和闭包

## 1.作用域是什么

> 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。



> 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值, 否则引擎就会抛出一个异常

**JS引擎查找变量的方式: LHS和RHS**

LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“= 赋值操作符的左侧或右侧”。赋值操作还有其他几种形式

因此在概念上最 好将其理解为“==赋值操作的目标是谁（LHS）==”以及“==谁是赋值操作的源头 （RHS）==”

**小测验** 

检验一下到目前的理解程度。把自己当作引擎，并同作用域进行一次“对话”： 

```js
function foo(a) {
  var b = a; 
  return a + b; 
} 
var c = foo( 2 ); 
```

1. 找到其中所有的 LHS 查询。（这里有 3 处！）
   - c=foo(2)
   - a=2
   - b=a
2. 找到其中所有的 RHS 查询。（这里有 4 处！)
   - foo的声明
   - var b = a; a的值
   -  return a + b;  a的值
   -  return a + b;  b的值

> ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对 结果的操作是非法或不合理的。

## 2.词法作用域

> 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的 标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。
>
> 全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此 可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引 用来对其进行访问
>
> `window.a`
>
> 通过这种技术可以访问那些被同名变量所遮蔽的全局变量。**但非全局的变量 如果被遮蔽了，无论如何都无法被访问到。**

## 3.函数作用域

> 区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位 置（不仅仅是一行代码，而是整个声明中的位置）。**如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式。**

行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。始终给函数表达式命名是一个最佳实践

```js
setTimeout( function timeoutHandler() { // <-- 快看，我有名字了！
	console.log( "I waited 1 second!" );
}, 1000 );
```

## 4.提升

> 先有蛋（声明）后有鸡（赋值）。

只有声明本身会被提升，而**赋值或其他运行逻辑会留在原地**。如果提升改变 了代码执行的顺序，会造成非常严重的破坏

> 函数声明会被提升，但是函数表达式却不会被提升

```js
foo(); //TypeError: foo is not a function
var foo = function bar() {
  console.log("...");
};
```

> 函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个 “重复”声明的代码中）是**函数会首先被提升，然后才是变量**
>
> 
>
> **声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。**

## 5.作用域闭包

> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用 域之外执行。

eg.

```js
function wait(message) {
  setTimeout(function timer() {
    console.log(message);
  }, 1000);
}
wait("Hello, closure!");
```

wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失，timer 函数依然保有 wait(..) 作用域的闭包。

 深入到引擎的内部原理中，内置的工具函数 setTimeout(..) 持有对一个参数的引用，这个 参数也许叫作 fn 或者 func，或者其他类似的名字。引擎会调用这个函数，在例子中就是 内部的 timer 函数，而词法作用域在这个过程中保持完整。这就是闭包。

> 本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，**只要使用了回调函数，实际上就是在使用闭包**

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);	// 6 6 6 6 6 
  }, i * 1000);
}
```

这段代码在运行时会以每秒一次的频率输出五次 6。**所有的回调函数在循环结束后才会被执行**

> 在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的 作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问

```js
for (var i=1; i<=5; i++) {
    (function(j) {
        setTimeout( function timer() {
        console.log( j );// 1 2 3 4 5
        }, j*1000 );
    })( i );
}
```

> for 循环头部的 let 声明还会有一 个特殊的行为。这个行为指出**变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量**

```js
for (let i=1; i<=5; i++) {
    setTimeout( function timer() {
        console.log( i );// 1 2 3 4 5 
    }, i*1000 );
}
```

### 模块

> 从模块中返回一个实际的对象并不是必须的，**也可以直接返回一个内部函数**。jQuery 就是一个很好的例子。jQuery 和 $ 标识符就是 jQuery 模块的公 共 API，但它们本身都是函数（由于函数也是对象，它们本身也可以拥有属 性）

**模块模式需要具备两个必要条件**

1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块 实例）。 
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态

**模块模式另一个简单但强大的变化用法是，命名将要作为公共 API 返回的对象：**

```js
var foo = (function CoolModule(id) {
  function change() {
    // 修改公共 API
    publicAPI.identify = identify2;
  }
  function identify1() {
    console.log(id);
  }
  function identify2() {
    console.log(id.toUpperCase());
  }
  var publicAPI = {
    change: change,
    identify: identify1,
  };
  return publicAPI;
})("foo module");
foo.identify(); // foo module
foo.change();
foo.identify(); // FOO MODULE
```

通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修 改，包括添加或删除方法和属性，以及修改它们的值

```js
var MyModules = (function Manager() {
  var modules = {};
  function define(name, deps, impl) {
    for (var i = 0; i < deps.length; i++) {
      deps[i] = modules[deps[i]];
    }
    modules[name] = impl.apply(impl, deps);
  }
  function get(name) {
    return modules[name];
  }

  return {
    define: define,
    get: get,
  };
})();

MyModules.define("bar", [], function () {
  function hello(who) {
    return "Let me introduce: " + who;
  }
  return {
    hello: hello,
  };
});
MyModules.define("foo", ["bar"], function (bar) {
  var hungry = "hippo";
  function awesome() {
    console.log(bar.hello(hungry).toUpperCase());
  }
  return {
    awesome: awesome,
  };
});
var bar = MyModules.get("bar");
var foo = MyModules.get("foo");
console.log(bar.hello("zhh")); // Let me introduce: zhh
foo.awesome(); // LET ME INTRODUCE: HIPP
```

> 模块管理器没有任何特殊的“魔力”。它们符合前面列出的模块模式的两个 特点：为函数定义引入包装函数，并保证它的返回值和模块的 API 保持一致。
