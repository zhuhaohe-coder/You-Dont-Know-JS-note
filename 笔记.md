# 作用域和闭包

## 1.作用域是什么

> 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。



> 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值, 否则引擎就会抛出一个异常

**JS引擎查找变量的方式: LHS和RHS**

LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“= 赋值操作符的左侧或右侧”。赋值操作还有其他几种形式

因此在概念上最 好将其理解为“==赋值操作的目标是谁（LHS）==”以及“==谁是赋值操作的源头 （RHS）==”

**小测验** 

检验一下到目前的理解程度。把自己当作引擎，并同作用域进行一次“对话”： 

```js
function foo(a) {
  var b = a; 
  return a + b; 
} 
var c = foo( 2 ); 
```

1. 找到其中所有的 LHS 查询。（这里有 3 处！）
   - c=foo(2)
   - a=2
   - b=a
2. 找到其中所有的 RHS 查询。（这里有 4 处！)
   - foo的声明
   - var b = a; a的值
   -  return a + b;  a的值
   -  return a + b;  b的值

> ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对 结果的操作是非法或不合理的。

## 2.词法作用域

> **词法作用域意味着作用域是由书写代码时函数声明的位置来决定的**。编译的词法分析阶段 基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它 们进行查找
>
> 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的 标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。
>
> 全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此 可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引 用来对其进行访问
>
> `window.a`
>
> 通过这种技术可以访问那些被同名变量所遮蔽的全局变量。**但非全局的变量 如果被遮蔽了，无论如何都无法被访问到。**

## 3.函数作用域

> 区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位 置（不仅仅是一行代码，而是整个声明中的位置）。**如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式。**

行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。始终给函数表达式命名是一个最佳实践

```js
setTimeout( function timeoutHandler() { // <-- 快看，我有名字了！
	console.log( "I waited 1 second!" );
}, 1000 );
```

## 4.提升

> 先有蛋（声明）后有鸡（赋值）。

只有声明本身会被提升，而**赋值或其他运行逻辑会留在原地**。如果提升改变 了代码执行的顺序，会造成非常严重的破坏

> 函数声明会被提升，但是函数表达式却不会被提升

```js
foo(); //TypeError: foo is not a function
var foo = function bar() {
  console.log("...");
};
```

> 函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个 “重复”声明的代码中）是**函数会首先被提升，然后才是变量**
>
> 
>
> **声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。**

## 5.作用域闭包

> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用 域之外执行。

eg.

```js
function wait(message) {
  setTimeout(function timer() {
    console.log(message);
  }, 1000);
}
wait("Hello, closure!");
```

wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失，timer 函数依然保有 wait(..) 作用域的闭包。

 深入到引擎的内部原理中，内置的工具函数 setTimeout(..) 持有对一个参数的引用，这个 参数也许叫作 fn 或者 func，或者其他类似的名字。引擎会调用这个函数，在例子中就是 内部的 timer 函数，而词法作用域在这个过程中保持完整。这就是闭包。

> 本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，**只要使用了回调函数，实际上就是在使用闭包**

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);	// 6 6 6 6 6 
  }, i * 1000);
}
```

这段代码在运行时会以每秒一次的频率输出五次 6。**所有的回调函数在循环结束后才会被执行**

> 在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的 作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问

```js
for (var i=1; i<=5; i++) {
    (function(j) {
        setTimeout( function timer() {
        console.log( j );// 1 2 3 4 5
        }, j*1000 );
    })( i );
}
```

> for 循环头部的 let 声明还会有一 个特殊的行为。这个行为指出**变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量**

```js
for (let i=1; i<=5; i++) {
    setTimeout( function timer() {
        console.log( i );// 1 2 3 4 5 
    }, i*1000 );
}
```

### 模块

> 从模块中返回一个实际的对象并不是必须的，**也可以直接返回一个内部函数**。jQuery 就是一个很好的例子。jQuery 和 $ 标识符就是 jQuery 模块的公 共 API，但它们本身都是函数（由于函数也是对象，它们本身也可以拥有属 性）

**模块模式需要具备两个必要条件**

1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块 实例）。 
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态

**模块模式另一个简单但强大的变化用法是，命名将要作为公共 API 返回的对象：**

```js
var foo = (function CoolModule(id) {
  function change() {
    // 修改公共 API
    publicAPI.identify = identify2;
  }
  function identify1() {
    console.log(id);
  }
  function identify2() {
    console.log(id.toUpperCase());
  }
  var publicAPI = {
    change: change,
    identify: identify1,
  };
  return publicAPI;
})("foo module");
foo.identify(); // foo module
foo.change();
foo.identify(); // FOO MODULE
```

通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修 改，包括添加或删除方法和属性，以及修改它们的值

```js
var MyModules = (function Manager() {
  var modules = {};
  function define(name, deps, impl) {
    for (var i = 0; i < deps.length; i++) {
      deps[i] = modules[deps[i]];
    }
    modules[name] = impl.apply(impl, deps);
  }
  function get(name) {
    return modules[name];
  }

  return {
    define: define,
    get: get,
  };
})();

MyModules.define("bar", [], function () {
  function hello(who) {
    return "Let me introduce: " + who;
  }
  return {
    hello: hello,
  };
});
MyModules.define("foo", ["bar"], function (bar) {
  var hungry = "hippo";
  function awesome() {
    console.log(bar.hello(hungry).toUpperCase());
  }
  return {
    awesome: awesome,
  };
});
var bar = MyModules.get("bar");
var foo = MyModules.get("foo");
console.log(bar.hello("zhh")); // Let me introduce: zhh
foo.awesome(); // LET ME INTRODUCE: HIPP
```

> 模块管理器没有任何特殊的“魔力”。它们符合前面列出的模块模式的两个 特点：为函数定义引入包装函数，并保证它的返回值和模块的 API 保持一致。

# this

## 1.关于this

> this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计得更加简洁并且易于复用。

### 误区

- **指向自身**

  ==this 并不像我们所想的那样指向函数本身==

  ```js
  function foo(num) {
    console.log("foo: " + num);
    // 记录 foo 被调用的次数
    this.count++;
  }
  
  foo.count = 0;
  
  for (let i = 0; i < 10; i++) {
    if (i > 5) {
      foo(i);
    }
  }
  // foo 被调用了多少次？
  console.log(foo.count); // 0
  ```

  foo(..) 确实被调用了 4 次，但是 **foo.count 仍然 是 0**。

  > 执行 foo.count = 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不是指向那个函数对象，所以**虽然属性名相同，根对象却并不相同**

  **==如果要从函数对象内部引用它自身，那只使用 this 是不够的。一般来说你需要通过一个指 向函数对象的词法标识符（变量）来引用它。==**

  解决方法:

  ```js
  function foo(num) {
      console.log( "foo: " + num );
      // 记录 foo 被调用的次数
      foo.count++;
  }
  ```

  这种方法同样回避了 this 的问题，并且完全依赖于变量 foo 的词法作用域。

  **另一种方法是强制 this 指向 foo 函数对象：**

  ```js
  for (let i=0; i<10; i++) {
  	if (i > 5) {
      // 使用 call(..) 可以确保 this 指向函数对象 foo 本身
      	foo.call( foo, i );
      }
  }
  ```

- **它的作用域**

  ==第二种常见的误解是，this 指向函数的作用域。==这个问题有点复杂，因为在某种情况下它 是正确的，但是在其他情况下它却是错误的。需要明确的是，**this 在任何情况下都不指向函数的词法作用域**。

  ```js
  function baz() {
    var a = 2;
    this.bar();
  }
  function bar() {
    console.log(this.a);
  }
  baz(); //TypeError: this.bar is not a function
  ```

  这段试图使用 this 联通 foo() 和 bar() 的词法作用域，从而让 bar() 可以访问 foo() 作用域里的变量 a。这是不可能实现的，你**不能使用 this 来引用一个词法作用域内部的东西。**

### this到底是什么

- this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。**this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。**
- 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包 含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。**this 就是记录的其中一个属性**，会在函数执行的过程中用到

## 2.this全面解析

### 绑定规则

#### 默认绑定

函数调用时应用了 this 的默认绑定，因此 **this 指向全局对象。**

```js
function foo() {
    console.log(this) //window
    console.log(this.a) //2
}
var a = 2
foo()

//node中
function foo() {
  console.log(this);    //global
  console.log(this.a);  //undefined
}
var a = 2;
foo(); 
```

如果使用严格模式（strict mode），那么**全局对象将无法使用默认绑定**，因此 this 会绑定 到 **undefined**：

#### 隐式绑定

> 当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。
>
> 对象属性引用链中只有最顶层或者说最后一层会影响调用位置。

```js
function foo() {
    console.log(this.a)
}
const obj2 = {
    a: 42,
    foo: foo,
}
const obj1 = {
    a: 2,
    obj2: obj2,
}
obj1.obj2.foo() // 42
```

**隐式丢失**

> 一个最常见的 this 绑定问题就是被隐式绑定的**函数**会丢失绑定对象，也就是说**它会应用默认绑定**

```js
function foo() {
    console.log(this.a)
}
const obj = {
    a: 2,
    foo: foo,
}
const bar = obj.foo // 函数别名！
var a = 'oops, global' // a 是全局对象的属性
bar() // "oops, global"
```

虽然 bar 是 obj.foo 的一个引用，**但是实际上，它引用的是 foo 函数本身**，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。

```js
function foo() {
    console.log(this.a)
}
function doFoo(fn) {
    // fn 其实引用的是 foo
    fn() // <-- 调用位置！
}
const obj = {
    a: 2,
    foo: foo,
}
var a = 'oops, global' // a 是全局对象的属性
doFoo(obj.foo) // "oops, global
```

**参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值**，所以结果和上一个例子一样

如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没有区别：

```js
function foo() {
    console.log(this.a)
}
var obj = {
    a: 2,
    foo: foo,
}
var a = 'oops, global' // a 是全局对象的属性
setTimeout(obj.foo, 100) // "oops, global
```

#### 显示绑定

**使用函数的 call(..) 和 apply(..) 方法**

它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。

> 如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对 象，这个原始值会被转换成它的对象形式（也就是 new String(..)、new Boolean(..) 或者 new Number(..)）。这通常被称为“装箱”

从 this 绑定的角度来说，call(..) 和 apply(..) 是一样的，它们的区别体现 在其他的参数上

##### 硬绑定

```js
function foo() {
    console.log(this.a)
}
var obj = {
    a: 2,
}
var a = 10
var bar = function () {
    foo.call(obj)
}
bar() // 2
setTimeout(bar, 100) // 2
// 硬绑定的 bar 不可能再修改它的 this
bar.call(window) // 2
```

我们创建了函数 bar()，并在它的内部手动调用 了 foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj。无论之后如何调用函数 bar，它 总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为**硬绑定。**

==硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值：==

```js
function foo(something) {
    console.log( this.a, something );
    return this.a + something;
}
var obj = {
	a:2
};
var bar = function() {
	return foo.apply( obj, arguments );
};
var b = bar( 3 ); // 2 3
console.log( b ); // 5
```

另一种使用方法是创建一个可以重复使用的辅助函数： 

```js
function foo(something) {
    console.log( this.a, something );
    return this.a + something;
}
// 简单的辅助绑定函数
function bind(fn, obj) {
    return function() {
    	return fn.apply( obj, arguments );
    };
}
var obj = {
a:2
};
var bar = bind( foo, obj );
var b = bar( 3 ); // 2 3
console.log( b ); // 5
```

由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 **Function.prototype. bind**:

> Function.prototype.bind(..) 会创建一个 新的包装函数，这个函数会**忽略它当前的 this 绑定**（无论绑定的对象是什么），并把我们提供的对象绑定到 this 上

```js
function foo(something) {
    console.log( this.a, something );
    return this.a + something;
}
var obj = {
	a:2
};
var bar = foo.bind( obj );
var b = bar( 3 ); // 2 3
console.log( b ); // 5
```

##### API调用的“上下文”

> 第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调函数使用指定的 this。

```js
function foo(el) {
	console.log( el, this.id );
}
var obj = {
	id: "awesome"
};
// 调用 foo(..) 时把 this 绑定到 obj
[1, 2, 3].forEach( foo, obj );
// 1 awesome 
// 2 awesome 
// 3 awesome
```

#### new绑定

> JavaScript 中 new 的机制实际上和面向类的语言完全不同。

首先我们重新定义一下 JavaScript 中的“构造函数”。

在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们**只是被 new 操作符调用的普通函数**而已。

> 实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。

使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 

1. 创建（或者说构造）一个全新的对象。 
2. 这个新对象会被执行 [[ 原型 ]] 连接。 
3. 这个新对象会绑定到函数调用的 this。 
4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象

```js
function foo(a) {
	this.a = a;
}
var bar = new foo(2);
console.log( bar.a ); // 2
```

使用 new 来调用 foo(..) 时，我们会**构造一个新对象并把它绑定到 foo(..) 调用中的 this 上**。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。

## 3.优先级

**默认绑定的优先级是四条规则中最低的**

```js
function foo() {
console.log( this.a );
}
var obj1 = {
    a: 2,
    foo: foo
};
var obj2 = {
    a: 3,
    foo: foo
};
obj1.foo(); // 2
obj2.foo(); // 3
obj1.foo.call( obj2 ); // 3
obj2.foo.call( obj1 ); // 2
```

可以看到，**显式绑定优先级更高，也就是说在判断时应当先考虑是否可以应用显式绑定。**

```js
function foo(something) {
  this.a = something;
}
var obj1 = {
  foo: foo,
};
var obj2 = {};
obj1.foo(2);
console.log(obj1.a); // 2
obj1.foo.call(obj2, 3);
console.log(obj2.a); // 3
var bar = new obj1.foo(4);
console.log(obj1.a); // 2
console.log(bar.a); // 4
```

可以看到 **new 绑定比隐式绑定优先级高。**

```js
function foo(something) {
  this.a = something;
}
var obj1 = {};

const bar = foo.bind(obj1);
bar(2);
console.log(obj1.a); //2

const baz = new bar(3);
console.log(obj1.a); //2
console.log(baz.a); //3
```

new 修改了硬绑定（到 obj1 的）调用 bar(..) 中的 this, 故**new绑定的优先级更高**

> 优先级: new绑定 > 显示绑定 > 隐式绑定 > 默认绑定

## 4.绑定例外

### 被忽略的this

> 如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，**实际应用的是默认绑定规则**

```js
    function foo(){
        console.log(this.a);
    }
    var a = 2;
    foo.call(null)	//2
```

**在`node`环境下为`undefined`**

应用场景 :

```js
function foo(a,b) {
	console.log( "a:" + a + ", b:" + b );
}
// 把数组“展开”成参数
foo.apply( null, [2, 3] ); // a:2, b:3
// 使用 bind(..) 进行柯里化
var bar = foo.bind( null, 2 );
bar( 3 ); // a:2, b:3
```

然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了 this（比如第三方库中的一个函数），那默认绑定规则会把 this 绑定到全局对象（在浏览 器中这个对象是 window），这将导致不可预计的后果（比如修改全局对象）

**显而易见，这种方式可能会导致许多难以分析和追踪的 bug。**

#### 更安全的this

> 如果我们在忽略 this 绑定时总是传入一个 DMZ（demilitarized zone，非军事区） 对象，那就什么都不用担心了，因为任何对于this 的使用都会被限制在这个空对象中，不会对全局对象产生任何影响。

```js
function foo(a,b) {
	console.log( "a:" + a + ", b:" + b );
}
// 我们的 DMZ 空对象
var ø = Object.create( null );
// 把数组展开成参数
foo.apply( ø, [2, 3] ); // a:2, b:3
// 使用 bind(..) 进行柯里化
var bar = foo.bind( ø, 2 );
bar( 3 ); // a:2, b:3
```

在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null)。

**Object.create(null) 和 {} 很像， 但是 并不会创建 Object. prototype 这个委托，所以它比 {}“更空”**

### 间接引用

*间接引用*最容易在赋值时发生：

```js
function foo() {
    console.log(this.a);
}

var a = 2;
var o = { a: 3, foo: foo };
var p = { a: 4 };
o.foo(); // 3
(p.foo = o.foo)(); // 2
```

**赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()**。根据我们之前说过的，这里会应用默认绑定。

### 软绑定

> 硬绑定这种方式可以把 this 强制绑定到指定的对象（除了使用 new 时），防止函数调用应用默认绑定规则。问题在于，**硬绑定会大大降低函数的灵活性**，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。

**如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。**

```js
if (!Function.prototype.softBind) {
    Function.prototype.softBind = function (obj) {
        var fn = this;
        // 捕获所有 curried 参数
        var curried = [].slice.call(arguments, 1);
        var bound = function () {
            return fn.apply(
                !this || this === (window || global) ? obj : this,
                curried.concat.apply(curried, arguments)
            );
        };
        bound.prototype = Object.create(fn.prototype);
        return bound;
    };
}

function foo() {
    console.log("name: " + this.name);
}
var obj = { name: "obj" },
    obj2 = { name: "obj2" },
    obj3 = { name: "obj3" };
var fooOBJ = foo.softBind(obj);
fooOBJ(); //name: obj
obj2.foo = foo.softBind(obj);
obj2.foo(); // name: obj2 <---- 看！！！
// 调用对象上的方法, 隐式绑定
fooOBJ.call(obj3); // name: obj3 <---- 看！
setTimeout(obj2.foo, 10); // name: obj <---- 应用了软绑定
//这是一个函数引用,是从obj2对象中抽取出foo方法,走默认绑定
```

软绑定版本的 foo() 可以手动将 this 绑定到 obj2 或者 obj3 上，但**如果应用默认绑定，则会将 this 绑定到 obj**

## 5.this词法

> 箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 this

```js
function foo() {
  // 返回一个箭头函数
  return (a) => {
    //this 继承自 foo()
    console.log(this.a);
  };
}
var obj1 = {
  a: 2,
};
var obj2 = {
  a: 3,
};
var bar = foo.call(obj1);
bar(3); //2
```

**foo() 内部创建的箭头函数会捕获调用时 foo() 的 this**。由于 foo() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。（new 也不行）

## 6.小结

如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后 就可以顺序应用下面这四条规则来判断 this 的绑定对象。

1. 由 new 调用？绑定到新创建的对象。 
2. 由 call 或者 apply（或者 bind）调用？绑定到指定的对象。 
3. 由上下文对象调用？绑定到那个上下文对象。 
4. 默认：在严格模式下绑定到 undefined，否则绑定到全局对象。 

一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑 定，你可以**使用一个 DMZ 对象，比如 ø = Object.create(null)，以保护全局对象。** 

ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这其实和 ES6 之前代码中的 **self = this 机制**一样。

# 对象

## 1.语法

```js
//文字语法
var myObj = {
key: value
// ...
}
//构造形式
var myObj = new Object();
myObj.key = value;
```

> 构造形式和文字形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个键 / 值对，但是在构造形式中你必须逐个添加属性

## 2.类型

```js
console.log(typeof null);	//object
```

**对 null 执行 typeof null 时会返回字符串 "object"。实际上，null 本身是基本类型。**

> 不同的对象在底层都表示为二进制，**在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型**，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。

### 内置对象

> JavaScript 中还有一些对象子类型，通常被称为内置对象。

- String
- Number
- Boolean
- Object
- Function
- Array
- Date
- RegExp
- Error

这些内置对象从表现形式来说很像其他语言中的类型（type）或者类（class），比如 Java 中的 String 类。 

但是在 JavaScript 中，它们实际上只是一些内置函数。**这些内置函数可以当作构造函数来使用，从而可以构造一个对应子类型的新对象**。

```js
const strPrimitive = "I am a string";
typeof strPrimitive; // "string"
strPrimitive instanceof String; // false
const strObject = new String( "I am a string" );
typeof strObject; // "object"
strObject instanceof String; // true
// 检查 sub-type 对象
Object.prototype.toString.call( strObject ); // [object String]
```

原始值 "I am a string" 并不是一个对象，它只是一个字面量，并且是一个不可变的值。 如果要在这个字面量上执行一些操作，比如获取长度、访问其中某个字符等，那**需要将其转换为 String 对象**。

> 在必要时语言会自动把字符串字面量转换成一个 String 对象，也就是说**你并不需要显式创建一个对象。**
>
> 同样的事也会发生在数值字面量上
>
> null 和 undefined 没有对应的构造形式，它们只有文字形式。
>
> 相反，Date 只有构造，没有文字形式。

## 3.内容

> 在对象中，属性名永远都是字符串。如果你使用 string（字面量）以外的其他值作为属性 名，那它首先会被转换为一个字符串。

ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名： 

```js
var prefix = "foo"; 

var myObject = { [prefix + "bar"]:"hello", [prefix + "baz"]: "world" }; 

myObject["foobar"]; // hello 

myObject["foobaz"]; // world
```

### 属性描述符

```js
var myObject = {
a:2
};
Object.getOwnPropertyDescriptor( myObject, "a" );
// {
// value: 2,
// writable: true,
// enumerable: true,
// configurable: true
// }
```

**writable（可写）、 enumerable（可枚举）和、configurable（可配置）**

> 即便属性是 configurable:false，我们还是可以 把 writable 的状态由 true 改为 false，但是无法由 false 改为 true。
>
> 除了无法修改，configurable:false 还会禁止删除这个属性

### 不变性

1. **对象常量**

   结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性（不可修改、 重定义或者删除）：

   > 如果目标对象引用了其他对象（数组、对象、函数，等），其他对象的内容不受影响，仍然是可变的

   ```js
   var myObject = {};
   Object.defineProperty( myObject, "FAVORITE_NUMBER", {
       value: [42],
       writable: false,
       configurable: false
   } );
   myObject.FAVORITE_NUMBER=[7] //[42]
   myObject.FAVORITE_NUMBER.push(7);//[42,7]
   ```

2. **禁止扩展**

   如果你想禁止一个对象添加新属性并且保留已有属性， 可以使用 `Object.preventExtensions(..)`：

   ```js
   var myObject = {
   	a:2
   };
   Object.preventExtensions( myObject );
   myObject.b = 3;
   myObject.b; // undefined
   //在严格模式下，将会抛出 TypeError 错误。
   ```

3. **密封**

   密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（**可以修改属性的值**）

   > `Object.seal(..)` 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用 `Object.preventExtensions(..)` 并把所有现有属性标记为 `configurable:false`。

4. **冻结**

   `Object.freeze(..)` 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值

   > 这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意 直接属性的修改（不过就像我们之前说过的，这个对象引用的其他对象是不受影响的）。

### getter和setter

> 在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是**只能应用在单个属性上，无法应用在整个对象上**。getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏 函数，会在设置属性值时调用

当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为“**访问描述符**”（和“数据描述符”相对）。对于访问描述符来说，JavaScript 会**忽略它们的 value 和 writable 特性**，取而代之的是关心 set 和 get（还有 configurable 和 enumerable）特性。

```js
var myObject = {
// 给 a 定义一个 getter
    get a() {
    	return 2;
    }
};
Object.defineProperty(
    myObject, // 目标对象
    "b", // 属性名
    { // 描述符
        // 给 b 设置一个 getter
        get: function(){ return this.a * 2 },
        // 确保 b 会出现在对象的属性列表中
        enumerable: true
	}
);
myObject.a; // 2
myObject.b; // 4
```

不管是对象文字语法中的 get a() { .. }，还是 defineProperty(..) 中的显式定义，**二者都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数， 它的返回值会被当作属性访问的返回值：**

```js
var myObject = {
// 给 a 定义一个 getter
    get a() {
    	return 2;
    }
};
myObject.a = 3;
myObject.a; // 2
```

通常来说 getter 和 setter 是成对出现的（只定义一个的话 通常会产生意料之外的行为）：

```js
var myObject = {
// 给 a 定义一个 getter
    get a() {
    	return this._a_;
    },
    // 给 a 定义一个 setter
    set a(val) {
    	this._a_ = val * 2;
    }
};
myObject.a = 2;
myObject.a; // 4
```

### 存在性

myObject.a 的属性访问返回值可能是 undefined，但是这个值有可能 是属性中存储的 undefined，也可能是因为属性不存在所以返回 undefined。那么如何区分 这两种情况呢？

我们可以在不访问属性值的情况下判断对象中是否存在这个属性：

```js
var myObject = {
	a:2
};
("a" in myObject); // true
("b" in myObject); // false
myObject.hasOwnProperty( "a" ); // true
myObject.hasOwnProperty( "b" ); // false
```

==in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。==

==hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，**不会检查 [[Prototype]] 链。**==

有的普通对象都可以通过对于Object.prototype的委托hasOwnProperty(..)，但是有的对象可能没有连接到 Object.prototype（通过 **Object. create(null)** 来创建）。

在这种情况下，形如 myObejct.hasOwnProperty(..) 就会失败。

这时可以使用一种更加强硬的方法来进行判断：`Object.prototype.hasOwnProperty. call(myObject,"a")`，它借用基础的 hasOwnProperty(..) 方法并把它显式绑定myObject上

> 看起来 in 操作符可以检查容器内是否有某个值，但是它实际上检查的是某 个属性名是否存在。对于数组来说这个区别非常重要，**4 in [2, 4, 6] 的结 果并不是你期待的 True，因为 [2, 4, 6] 这个数组中包含的属性名是 0、1、 2，没有 4。**

```js
console.log(4 in [2, 4, 6]); //false
```

#### 枚举

```js
var myObject = {};
Object.defineProperty(
  myObject,
  "a",
  // 让 a 像普通属性一样可以枚举
  { enumerable: true, value: 2 }
);
Object.defineProperty(
  myObject,
  "b",
  // 让 b 不可枚举
  { enumerable: false, value: 3 }
);
myObject.b; // 3
"b" in myObject; // true
myObject.hasOwnProperty("b"); // true

for (var k in myObject) {
  console.log(k, myObject[k]);
}// a 2
```

可以看到，myObject.b 确实存在并且有访问值，但是却不会出现在 for..in 循环中（尽管 可以通过 in 操作符来判断是否存在）。原因是**“可枚举”就相当于“可以出现在对象属性 的遍历中”**。

> 在数组上应用 for..in 循环有时会产生出人意料的结果，因为**这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。**最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引

也可以通过另一种方式来区分属性是否可枚举:

```js
var myObject = { };
    Object.defineProperty(
    myObject,
    "a",
    // 让 a 像普通属性一样可以枚举
    { enumerable: true, value: 2 }
);
Object.defineProperty(
    myObject,
    "b",
    // 让 b 不可枚举
    { enumerable: false, value: 3 }
);
myObject.propertyIsEnumerable( "a" ); // true
myObject.propertyIsEnumerable( "b" ); // false
Object.keys( myObject ); // ["a"]
Object.getOwnPropertyNames( myObject ); // ["a", "b"]
```

propertyIsEnumerable(..) 会检查给定的属性名是否**直接存在于对象中（而不是在原型链上）**并且满足 enumerable:true。

Object.keys(..) 会返回一个数组，包含所有可枚举属性

Object.getOwnPropertyNames(..) 会返回一个数组，包含所有属性，无论它们是否可枚举

in 和 hasOwnProperty(..) 的区别在于是否查找 [[Prototype]] 链，然而，Object.keys(..) 和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性

### 遍历

> 遍历对 象属性时的顺序是不确定的，在不同的 JavaScript 引擎中可能不一样。因此， 在不同的环境中需要保证一致性时，一定不要相信任何观察到的顺序，它们 是不可靠的

#### for...in与for...of

> `for..in `遍历对象是无法直接获取属性值的，因为它实际上遍历的是对象中的所有可 枚举属性，你需要手动获取属性值
>
> `for..of`可以直接遍历数组的值（**如果对象本身定义了迭代器的话也可以遍历对象**）
>
> `for..of `循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值。

```js
const myArray = [1, 2, 3];
for (key in myArray) {
  console.log(key);
}
console.log("============");
for (value of myArray) {
  console.log(value);
}
/*
    0
    1
    2
    ============
    1
    2
    3
*/
```

#### 数组和对象

数组有内置的 @@iterator，因此 for..of 可以直接应用在数组上。

```js
var myArray = [ 1, 2, 3 ];
var it = myArray[Symbol.iterator]();
it.next(); // { value:1, done:false } 
it.next(); // { value:2, done:false } 
it.next(); // { value:3, done:false } 
it.next(); // { done:true }
```

> @@iterator 本身并不是一个迭代器对象，而是一个返回迭代器对象的函数

普通的对象没有内置的 @@iterator，所以无法自动完成 for..of 遍历。

你可以给任何想遍历的对象定义 @@iterator

```js
const myObject = {
  a: 2,
  b: 3,
};

Object.defineProperty(myObject, Symbol.iterator, {
  enumerable: false,
  writable: false,
  configurable: true,
  value: function () {
    const o = this;
    let idx = 0;
    const ks = Object.keys(o);
    return {
      next: function () {
        return {
          value: o[ks[idx++]],
          done: idx > ks.length,
        };
      },
    };
  },
});
const it = myObject[Symbol.iterator]();
it.next(); // { value:2, done:false } 
it.next(); // { value:3, done:false } 
it.next(); // { value:undefined, done:true }
for (let v of myObject) {
  console.log(v);
}
// 2
// 3
```

## 混合对象--类

> **对于真正的类来说，构造函数是属于类的**。然而，在 JavaScript 中恰好相反——实际 上“**类”是属于构造函数的**（类似 `Foo.prototype...` 这样的类型引用）。由于 JavaScript 中父类和子类的关系只存在于两者构造函数对应的 .prototype 对象中，因此**它们的构造函数之间并不存在直接联系，从而无法简单地实现两者的 相对引用（在 ES6 的类中可以通过 super 来“解决”这个问题)**

### 混入

> 在继承或者实例化时，JavaScript 的对象机制并不会自动执行复制行为。简单来说， JavaScript 中只有对象，并不存在可以被实例化的“类”。一个对象并不会被复制到其他对 象，它们会被关联起来

由于在其他语言中类表现出来的都是复制行为，因此 JavaScript 开发者也想出了一个方法来 **模拟类的复制行为，这个方法就是混入**。

#### 总结

类是一种设计模式。许多语言提供了对于面向类软件设计的原生语法。

JavaScript 也有类 似的语法，但是和其他语言中的类完全不同。 

类意味着复制。 

传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。

多态（在继承链的不同层次名称相同但是功能不同的函数）看起来似乎是从子类引用父 类，但是本质上引用的其实是复制的结果。 

JavaScript 并不会（像类那样）自动创建对象的副本。 

混入模式（无论显式还是隐式）可以用来模拟类的复制行为，但是通常会产生丑陋并且脆 弱的语法，比如显式伪多态（`OtherObj.methodName.call(this, ...)`），这会让代码更加难 懂并且难以维护。此外，显式混入实际上无法完全模拟类的复制行为，因为对象（和函数！别忘了函数也 是对象）只能复制引用，无法复制被引用的对象或者函数本身。忽视这一点会导致许多问题。 

总地来说，在 JavaScript 中模拟类是得不偿失的，虽然能解决当前的问题，但是可能会埋下更多的隐患

