# 作用域和闭包

## 1.作用域是什么

> 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。



> 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值, 否则引擎就会抛出一个异常

**JS引擎查找变量的方式: LHS和RHS**

LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“= 赋值操作符的左侧或右侧”。赋值操作还有其他几种形式

因此在概念上最 好将其理解为“==赋值操作的目标是谁（LHS）==”以及“==谁是赋值操作的源头 （RHS）==”

**小测验** 

检验一下到目前的理解程度。把自己当作引擎，并同作用域进行一次“对话”： 

```js
function foo(a) {
  var b = a; 
  return a + b; 
} 
var c = foo( 2 ); 
```

1. 找到其中所有的 LHS 查询。（这里有 3 处！）
   - c=foo(2)
   - a=2
   - b=a
2. 找到其中所有的 RHS 查询。（这里有 4 处！)
   - foo的声明
   - var b = a; a的值
   -  return a + b;  a的值
   -  return a + b;  b的值

> ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对 结果的操作是非法或不合理的。

## 2.词法作用域

> **词法作用域意味着作用域是由书写代码时函数声明的位置来决定的**。编译的词法分析阶段 基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它 们进行查找
>
> 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的 标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。
>
> 全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此 可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引 用来对其进行访问
>
> `window.a`
>
> 通过这种技术可以访问那些被同名变量所遮蔽的全局变量。**但非全局的变量 如果被遮蔽了，无论如何都无法被访问到。**

## 3.函数作用域

> 区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位 置（不仅仅是一行代码，而是整个声明中的位置）。**如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式。**

行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。始终给函数表达式命名是一个最佳实践

```js
setTimeout( function timeoutHandler() { // <-- 快看，我有名字了！
	console.log( "I waited 1 second!" );
}, 1000 );
```

## 4.提升

> 先有蛋（声明）后有鸡（赋值）。

只有声明本身会被提升，而**赋值或其他运行逻辑会留在原地**。如果提升改变 了代码执行的顺序，会造成非常严重的破坏

> 函数声明会被提升，但是函数表达式却不会被提升

```js
foo(); //TypeError: foo is not a function
var foo = function bar() {
  console.log("...");
};
```

> 函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个 “重复”声明的代码中）是**函数会首先被提升，然后才是变量**
>
> 
>
> **声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。**

## 5.作用域闭包

> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用 域之外执行。

eg.

```js
function wait(message) {
  setTimeout(function timer() {
    console.log(message);
  }, 1000);
}
wait("Hello, closure!");
```

wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失，timer 函数依然保有 wait(..) 作用域的闭包。

 深入到引擎的内部原理中，内置的工具函数 setTimeout(..) 持有对一个参数的引用，这个 参数也许叫作 fn 或者 func，或者其他类似的名字。引擎会调用这个函数，在例子中就是 内部的 timer 函数，而词法作用域在这个过程中保持完整。这就是闭包。

> 本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，**只要使用了回调函数，实际上就是在使用闭包**

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);	// 6 6 6 6 6 
  }, i * 1000);
}
```

这段代码在运行时会以每秒一次的频率输出五次 6。**所有的回调函数在循环结束后才会被执行**

> 在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的 作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问

```js
for (var i=1; i<=5; i++) {
    (function(j) {
        setTimeout( function timer() {
        console.log( j );// 1 2 3 4 5
        }, j*1000 );
    })( i );
}
```

> for 循环头部的 let 声明还会有一 个特殊的行为。这个行为指出**变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量**

```js
for (let i=1; i<=5; i++) {
    setTimeout( function timer() {
        console.log( i );// 1 2 3 4 5 
    }, i*1000 );
}
```

### 模块

> 从模块中返回一个实际的对象并不是必须的，**也可以直接返回一个内部函数**。jQuery 就是一个很好的例子。jQuery 和 $ 标识符就是 jQuery 模块的公 共 API，但它们本身都是函数（由于函数也是对象，它们本身也可以拥有属 性）

**模块模式需要具备两个必要条件**

1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块 实例）。 
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态

**模块模式另一个简单但强大的变化用法是，命名将要作为公共 API 返回的对象：**

```js
var foo = (function CoolModule(id) {
  function change() {
    // 修改公共 API
    publicAPI.identify = identify2;
  }
  function identify1() {
    console.log(id);
  }
  function identify2() {
    console.log(id.toUpperCase());
  }
  var publicAPI = {
    change: change,
    identify: identify1,
  };
  return publicAPI;
})("foo module");
foo.identify(); // foo module
foo.change();
foo.identify(); // FOO MODULE
```

通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修 改，包括添加或删除方法和属性，以及修改它们的值

```js
var MyModules = (function Manager() {
  var modules = {};
  function define(name, deps, impl) {
    for (var i = 0; i < deps.length; i++) {
      deps[i] = modules[deps[i]];
    }
    modules[name] = impl.apply(impl, deps);
  }
  function get(name) {
    return modules[name];
  }

  return {
    define: define,
    get: get,
  };
})();

MyModules.define("bar", [], function () {
  function hello(who) {
    return "Let me introduce: " + who;
  }
  return {
    hello: hello,
  };
});
MyModules.define("foo", ["bar"], function (bar) {
  var hungry = "hippo";
  function awesome() {
    console.log(bar.hello(hungry).toUpperCase());
  }
  return {
    awesome: awesome,
  };
});
var bar = MyModules.get("bar");
var foo = MyModules.get("foo");
console.log(bar.hello("zhh")); // Let me introduce: zhh
foo.awesome(); // LET ME INTRODUCE: HIPP
```

> 模块管理器没有任何特殊的“魔力”。它们符合前面列出的模块模式的两个 特点：为函数定义引入包装函数，并保证它的返回值和模块的 API 保持一致。

# this

## 1.关于this

> this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计得更加简洁并且易于复用。

### 误区

- **指向自身**

  ==this 并不像我们所想的那样指向函数本身==

  ```js
  function foo(num) {
    console.log("foo: " + num);
    // 记录 foo 被调用的次数
    this.count++;
  }
  
  foo.count = 0;
  
  for (let i = 0; i < 10; i++) {
    if (i > 5) {
      foo(i);
    }
  }
  // foo 被调用了多少次？
  console.log(foo.count); // 0
  ```

  foo(..) 确实被调用了 4 次，但是 **foo.count 仍然 是 0**。

  > 执行 foo.count = 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不是指向那个函数对象，所以**虽然属性名相同，根对象却并不相同**

  **==如果要从函数对象内部引用它自身，那只使用 this 是不够的。一般来说你需要通过一个指向函数对象的词法标识符（变量）来引用它。==**

  解决方法:

  ```js
  function foo(num) {
      console.log( "foo: " + num );
      // 记录 foo 被调用的次数
      foo.count++;
  }
  ```

  这种方法同样回避了 this 的问题，并且完全依赖于变量 foo 的词法作用域。

  **另一种方法是强制 this 指向 foo 函数对象：**

  ```js
  for (let i=0; i<10; i++) {
  	if (i > 5) {
      // 使用 call(..) 可以确保 this 指向函数对象 foo 本身
      	foo.call( foo, i );
      }
  }
  ```

- **它的作用域**

  ==第二种常见的误解是，this 指向函数的作用域。==这个问题有点复杂，因为在某种情况下它 是正确的，但是在其他情况下它却是错误的。需要明确的是，**this 在任何情况下都不指向函数的词法作用域**。

  ```js
  function baz() {
    var a = 2;
    this.bar();
  }
  function bar() {
    console.log(this.a);
  }
  baz(); //TypeError: this.bar is not a function
  ```

  这段试图使用 this 联通 foo() 和 bar() 的词法作用域，从而让 bar() 可以访问 foo() 作用域里的变量 a。这是不可能实现的，你**不能使用 this 来引用一个词法作用域内部的东西。**

### this到底是什么

- this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。**this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。**
- 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包 含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。**this 就是记录的其中一个属性**，会在函数执行的过程中用到

## 2.this全面解析

### 绑定规则

#### 默认绑定

函数调用时应用了 this 的默认绑定，因此 **this 指向全局对象。**

```js
function foo() {
    console.log(this) //window
    console.log(this.a) //2
}
var a = 2
foo()

//node中
function foo() {
  console.log(this);    //global
  console.log(this.a);  //undefined
}
var a = 2;
foo(); 
```

如果使用严格模式（strict mode），那么**全局对象将无法使用默认绑定**，因此 this 会绑定 到 **undefined**：

#### 隐式绑定

> 当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。
>
> 对象属性引用链中只有最顶层或者说最后一层会影响调用位置。

```js
function foo() {
    console.log(this.a)
}
const obj2 = {
    a: 42,
    foo: foo,
}
const obj1 = {
    a: 2,
    obj2: obj2,
}
obj1.obj2.foo() // 42
```

**隐式丢失**

> 一个最常见的 this 绑定问题就是被隐式绑定的**函数**会丢失绑定对象，也就是说**它会应用默认绑定**

```js
function foo() {
    console.log(this.a)
}
const obj = {
    a: 2,
    foo: foo,
}
const bar = obj.foo // 函数别名！
var a = 'oops, global' // a 是全局对象的属性
bar() // "oops, global"
```

虽然 bar 是 obj.foo 的一个引用，**但是实际上，它引用的是 foo 函数本身**，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。

```js
function foo() {
    console.log(this.a)
}
function doFoo(fn) {
    // fn 其实引用的是 foo
    fn() // <-- 调用位置！
}
const obj = {
    a: 2,
    foo: foo,
}
var a = 'oops, global' // a 是全局对象的属性
doFoo(obj.foo) // "oops, global
```

**参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值**，所以结果和上一个例子一样

如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没有区别：

```js
function foo() {
    console.log(this.a)
}
var obj = {
    a: 2,
    foo: foo,
}
var a = 'oops, global' // a 是全局对象的属性
setTimeout(obj.foo, 100) // "oops, global
```

#### 显示绑定

**使用函数的 call(..) 和 apply(..) 方法**

它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。

> 如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对 象，这个原始值会被转换成它的对象形式（也就是 new String(..)、new Boolean(..) 或者 new Number(..)）。这通常被称为“装箱”

从 this 绑定的角度来说，call(..) 和 apply(..) 是一样的，它们的区别体现 在其他的参数上

##### 硬绑定

```js
function foo() {
    console.log(this.a)
}
var obj = {
    a: 2,
}
var a = 10
var bar = function () {
    foo.call(obj)
}
bar() // 2
setTimeout(bar, 100) // 2
// 硬绑定的 bar 不可能再修改它的 this
bar.call(window) // 2
```

我们创建了函数 bar()，并在它的内部手动调用 了 foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj。无论之后如何调用函数 bar，它 总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为**硬绑定。**

==硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值：==

```js
function foo(something) {
    console.log( this.a, something );
    return this.a + something;
}
var obj = {
	a:2
};
var bar = function() {
	return foo.apply( obj, arguments );
};
var b = bar( 3 ); // 2 3
console.log( b ); // 5
```

另一种使用方法是创建一个可以重复使用的辅助函数： 

```js
function foo(something) {
    console.log( this.a, something );
    return this.a + something;
}
// 简单的辅助绑定函数
function bind(fn, obj) {
    return function() {
    	return fn.apply( obj, arguments );
    };
}
var obj = {
a:2
};
var bar = bind( foo, obj );
var b = bar( 3 ); // 2 3
console.log( b ); // 5
```

由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 **Function.prototype. bind**:

> Function.prototype.bind(..) 会创建一个 新的包装函数，这个函数会**忽略它当前的 this 绑定**（无论绑定的对象是什么），并把我们提供的对象绑定到 this 上

```js
function foo(something) {
    console.log( this.a, something );
    return this.a + something;
}
var obj = {
	a:2
};
var bar = foo.bind( obj );
var b = bar( 3 ); // 2 3
console.log( b ); // 5
```

##### API调用的“上下文”

> 第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调函数使用指定的 this。

```js
function foo(el) {
	console.log( el, this.id );
}
var obj = {
	id: "awesome"
};
// 调用 foo(..) 时把 this 绑定到 obj
[1, 2, 3].forEach( foo, obj );
// 1 awesome 
// 2 awesome 
// 3 awesome
```

#### new绑定

> JavaScript 中 new 的机制实际上和面向类的语言完全不同。

首先我们重新定义一下 JavaScript 中的“构造函数”。

在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们**只是被 new 操作符调用的普通函数**而已。

> 实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。

使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 

1. 创建（或者说构造）一个全新的对象。 
2. 这个新对象会被执行 [[ 原型 ]] 连接。 
3. 这个新对象会绑定到函数调用的 this。 
4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象

```js
function foo(a) {
	this.a = a;
}
var bar = new foo(2);
console.log( bar.a ); // 2
```

使用 new 来调用 foo(..) 时，我们会**构造一个新对象并把它绑定到 foo(..) 调用中的 this 上**。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。

## 3.优先级

**默认绑定的优先级是四条规则中最低的**

```js
function foo() {
console.log( this.a );
}
var obj1 = {
    a: 2,
    foo: foo
};
var obj2 = {
    a: 3,
    foo: foo
};
obj1.foo(); // 2
obj2.foo(); // 3
obj1.foo.call( obj2 ); // 3
obj2.foo.call( obj1 ); // 2
```

可以看到，**显式绑定优先级更高，也就是说在判断时应当先考虑是否可以应用显式绑定。**

```js
function foo(something) {
  this.a = something;
}
var obj1 = {
  foo: foo,
};
var obj2 = {};
obj1.foo(2);
console.log(obj1.a); // 2
obj1.foo.call(obj2, 3);
console.log(obj2.a); // 3
var bar = new obj1.foo(4);
console.log(obj1.a); // 2
console.log(bar.a); // 4
```

可以看到 **new 绑定比隐式绑定优先级高。**

```js
function foo(something) {
  this.a = something;
}
var obj1 = {};

const bar = foo.bind(obj1);
bar(2);
console.log(obj1.a); //2

const baz = new bar(3);
console.log(obj1.a); //2
console.log(baz.a); //3
```

new 修改了硬绑定（到 obj1 的）调用 bar(..) 中的 this, 故**new绑定的优先级更高**

> 优先级: new绑定 > 显示绑定 > 隐式绑定 > 默认绑定

## 4.绑定例外

### 被忽略的this

> 如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，**实际应用的是默认绑定规则**

```js
    function foo(){
        console.log(this.a);
    }
    var a = 2;
    foo.call(null)	//2
```

**在`node`环境下为`undefined`**

应用场景 :

```js
function foo(a,b) {
	console.log( "a:" + a + ", b:" + b );
}
// 把数组“展开”成参数
foo.apply( null, [2, 3] ); // a:2, b:3
// 使用 bind(..) 进行柯里化
var bar = foo.bind( null, 2 );
bar( 3 ); // a:2, b:3
```

然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了 this（比如第三方库中的一个函数），那默认绑定规则会把 this 绑定到全局对象（在浏览 器中这个对象是 window），这将导致不可预计的后果（比如修改全局对象）

**显而易见，这种方式可能会导致许多难以分析和追踪的 bug。**

#### 更安全的this

> 如果我们在忽略 this 绑定时总是传入一个 DMZ（demilitarized zone，非军事区） 对象，那就什么都不用担心了，因为任何对于this 的使用都会被限制在这个空对象中，不会对全局对象产生任何影响。

```js
function foo(a,b) {
	console.log( "a:" + a + ", b:" + b );
}
// 我们的 DMZ 空对象
var ø = Object.create( null );
// 把数组展开成参数
foo.apply( ø, [2, 3] ); // a:2, b:3
// 使用 bind(..) 进行柯里化
var bar = foo.bind( ø, 2 );
bar( 3 ); // a:2, b:3
```

在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null)。

**Object.create(null) 和 {} 很像， 但是 并不会创建 Object. prototype 这个委托，所以它比 {}“更空”**

### 间接引用

*间接引用*最容易在赋值时发生：

```js
function foo() {
    console.log(this.a);
}

var a = 2;
var o = { a: 3, foo: foo };
var p = { a: 4 };
o.foo(); // 3
(p.foo = o.foo)(); // 2
```

**赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()**。根据我们之前说过的，这里会应用默认绑定。

### 软绑定

> 硬绑定这种方式可以把 this 强制绑定到指定的对象（除了使用 new 时），防止函数调用应用默认绑定规则。问题在于，**硬绑定会大大降低函数的灵活性**，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。

**如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。**

```js
if (!Function.prototype.softBind) {
    Function.prototype.softBind = function (obj) {
        var fn = this;
        // 捕获所有 curried 参数
        var curried = [].slice.call(arguments, 1);
        var bound = function () {
            return fn.apply(
                !this || this === (window || global) ? obj : this,
                curried.concat.apply(curried, arguments)
            );
        };
        bound.prototype = Object.create(fn.prototype);
        return bound;
    };
}

function foo() {
    console.log("name: " + this.name);
}
var obj = { name: "obj" },
    obj2 = { name: "obj2" },
    obj3 = { name: "obj3" };
var fooOBJ = foo.softBind(obj);
fooOBJ(); //name: obj
obj2.foo = foo.softBind(obj);
obj2.foo(); // name: obj2 <---- 看！！！
// 调用对象上的方法, 隐式绑定
fooOBJ.call(obj3); // name: obj3 <---- 看！
setTimeout(obj2.foo, 10); // name: obj <---- 应用了软绑定
//这是一个函数引用,是从obj2对象中抽取出foo方法,走默认绑定
```

软绑定版本的 foo() 可以手动将 this 绑定到 obj2 或者 obj3 上，但**如果应用默认绑定，则会将 this 绑定到 obj**

## 5.this词法

> 箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 this

```js
function foo() {
  // 返回一个箭头函数
  return (a) => {
    //this 继承自 foo()
    console.log(this.a);
  };
}
var obj1 = {
  a: 2,
};
var obj2 = {
  a: 3,
};
var bar = foo.call(obj1);
bar(3); //2
```

**foo() 内部创建的箭头函数会捕获调用时 foo() 的 this**。由于 foo() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。（new 也不行）

## 6.小结

如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后 就可以顺序应用下面这四条规则来判断 this 的绑定对象。

1. 由 new 调用？绑定到新创建的对象。 
2. 由 call 或者 apply（或者 bind）调用？绑定到指定的对象。 
3. 由上下文对象调用？绑定到那个上下文对象。 
4. 默认：在严格模式下绑定到 undefined，否则绑定到全局对象。 

一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑 定，你可以**使用一个 DMZ 对象，比如 ø = Object.create(null)，以保护全局对象。** 

ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这其实和 ES6 之前代码中的 **self = this 机制**一样。

# 对象

## 1.语法

```js
//文字语法
var myObj = {
key: value
// ...
}
//构造形式
var myObj = new Object();
myObj.key = value;
```

> 构造形式和文字形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个键 / 值对，但是在构造形式中你必须逐个添加属性

## 2.类型

```js
console.log(typeof null);	//object
```

**对 null 执行 typeof null 时会返回字符串 "object"。实际上，null 本身是基本类型。**

> 不同的对象在底层都表示为二进制，**在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型**，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。

### 内置对象

> JavaScript 中还有一些对象子类型，通常被称为内置对象。

- String
- Number
- Boolean
- Object
- Function
- Array
- Date
- RegExp
- Error

这些内置对象从表现形式来说很像其他语言中的类型（type）或者类（class），比如 Java 中的 String 类。 

但是在 JavaScript 中，它们实际上只是一些内置函数。**这些内置函数可以当作构造函数来使用，从而可以构造一个对应子类型的新对象**。

```js
const strPrimitive = "I am a string";
typeof strPrimitive; // "string"
strPrimitive instanceof String; // false
const strObject = new String( "I am a string" );
typeof strObject; // "object"
strObject instanceof String; // true
// 检查 sub-type 对象
Object.prototype.toString.call( strObject ); // [object String]
```

原始值 "I am a string" 并不是一个对象，它只是一个字面量，并且是一个不可变的值。 如果要在这个字面量上执行一些操作，比如获取长度、访问其中某个字符等，那**需要将其转换为 String 对象**。

> 在必要时语言会自动把字符串字面量转换成一个 String 对象，也就是说**你并不需要显式创建一个对象。**
>
> 同样的事也会发生在数值字面量上
>
> null 和 undefined 没有对应的构造形式，它们只有文字形式。
>
> 相反，Date 只有构造，没有文字形式。

## 3.内容

> 在对象中，属性名永远都是字符串。如果你使用 string（字面量）以外的其他值作为属性 名，那它首先会被转换为一个字符串。

ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名： 

```js
var prefix = "foo"; 

var myObject = { [prefix + "bar"]:"hello", [prefix + "baz"]: "world" }; 

myObject["foobar"]; // hello 

myObject["foobaz"]; // world
```

### 属性描述符

```js
var myObject = {
a:2
};
Object.getOwnPropertyDescriptor( myObject, "a" );
// {
// value: 2,
// writable: true,
// enumerable: true,
// configurable: true
// }
```

**writable（可写）、 enumerable（可枚举）和、configurable（可配置）**

> 即便属性是 configurable:false，我们还是可以 把 writable 的状态由 true 改为 false，但是无法由 false 改为 true。
>
> 除了无法修改，configurable:false 还会禁止删除这个属性

### 不变性

1. **对象常量**

   结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性（不可修改、 重定义或者删除）：

   > 如果目标对象引用了其他对象（数组、对象、函数，等），其他对象的内容不受影响，仍然是可变的

   ```js
   var myObject = {};
   Object.defineProperty( myObject, "FAVORITE_NUMBER", {
       value: [42],
       writable: false,
       configurable: false
   } );
   myObject.FAVORITE_NUMBER=[7] //[42]
   myObject.FAVORITE_NUMBER.push(7);//[42,7]
   ```

2. **禁止扩展**

   如果你想禁止一个对象添加新属性并且保留已有属性， 可以使用 `Object.preventExtensions(..)`：

   ```js
   var myObject = {
   	a:2
   };
   Object.preventExtensions( myObject );
   myObject.b = 3;
   myObject.b; // undefined
   //在严格模式下，将会抛出 TypeError 错误。
   ```

3. **密封**

   密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（**可以修改属性的值**）

   > `Object.seal(..)` 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用 `Object.preventExtensions(..)` 并把所有现有属性标记为 `configurable:false`。

4. **冻结**

   `Object.freeze(..)` 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值

   > 这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意 直接属性的修改（不过就像我们之前说过的，这个对象引用的其他对象是不受影响的）。

### getter和setter

> 在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是**只能应用在单个属性上，无法应用在整个对象上**。getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏 函数，会在设置属性值时调用

当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为“**访问描述符**”（和“数据描述符”相对）。对于访问描述符来说，JavaScript 会**忽略它们的 value 和 writable 特性**，取而代之的是关心 set 和 get（还有 configurable 和 enumerable）特性。

```js
var myObject = {
// 给 a 定义一个 getter
    get a() {
    	return 2;
    }
};
Object.defineProperty(
    myObject, // 目标对象
    "b", // 属性名
    { // 描述符
        // 给 b 设置一个 getter
        get: function(){ return this.a * 2 },
        // 确保 b 会出现在对象的属性列表中
        enumerable: true
	}
);
myObject.a; // 2
myObject.b; // 4
```

不管是对象文字语法中的 get a() { .. }，还是 defineProperty(..) 中的显式定义，**二者都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数， 它的返回值会被当作属性访问的返回值：**

```js
var myObject = {
// 给 a 定义一个 getter
    get a() {
    	return 2;
    }
};
myObject.a = 3;
myObject.a; // 2
```

通常来说 getter 和 setter 是成对出现的（只定义一个的话 通常会产生意料之外的行为）：

```js
var myObject = {
// 给 a 定义一个 getter
    get a() {
    	return this._a_;
    },
    // 给 a 定义一个 setter
    set a(val) {
    	this._a_ = val * 2;
    }
};
myObject.a = 2;
myObject.a; // 4
```

### 存在性

myObject.a 的属性访问返回值可能是 undefined，但是这个值有可能 是属性中存储的 undefined，也可能是因为属性不存在所以返回 undefined。那么如何区分 这两种情况呢？

我们可以在不访问属性值的情况下判断对象中是否存在这个属性：

```js
var myObject = {
	a:2
};
("a" in myObject); // true
("b" in myObject); // false
myObject.hasOwnProperty( "a" ); // true
myObject.hasOwnProperty( "b" ); // false
```

==in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。==

==hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，**不会检查 [[Prototype]] 链。**==

有的普通对象都可以通过对于Object.prototype的委托hasOwnProperty(..)，但是有的对象可能没有连接到 Object.prototype（通过 **Object. create(null)** 来创建）。

在这种情况下，形如 myObejct.hasOwnProperty(..) 就会失败。

这时可以使用一种更加强硬的方法来进行判断：`Object.prototype.hasOwnProperty. call(myObject,"a")`，它借用基础的 hasOwnProperty(..) 方法并把它显式绑定myObject上

> 看起来 in 操作符可以检查容器内是否有某个值，但是它实际上检查的是某 个属性名是否存在。对于数组来说这个区别非常重要，**4 in [2, 4, 6] 的结 果并不是你期待的 True，因为 [2, 4, 6] 这个数组中包含的属性名是 0、1、 2，没有 4。**

```js
console.log(4 in [2, 4, 6]); //false
```

#### 枚举

```js
var myObject = {};
Object.defineProperty(
  myObject,
  "a",
  // 让 a 像普通属性一样可以枚举
  { enumerable: true, value: 2 }
);
Object.defineProperty(
  myObject,
  "b",
  // 让 b 不可枚举
  { enumerable: false, value: 3 }
);
myObject.b; // 3
"b" in myObject; // true
myObject.hasOwnProperty("b"); // true

for (var k in myObject) {
  console.log(k, myObject[k]);
}// a 2
```

可以看到，myObject.b 确实存在并且有访问值，但是却不会出现在 for..in 循环中（尽管 可以通过 in 操作符来判断是否存在）。原因是**“可枚举”就相当于“可以出现在对象属性 的遍历中”**。

> 在数组上应用 for..in 循环有时会产生出人意料的结果，因为**这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。**最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引

也可以通过另一种方式来区分属性是否可枚举:

```js
var myObject = { };
    Object.defineProperty(
    myObject,
    "a",
    // 让 a 像普通属性一样可以枚举
    { enumerable: true, value: 2 }
);
Object.defineProperty(
    myObject,
    "b",
    // 让 b 不可枚举
    { enumerable: false, value: 3 }
);
myObject.propertyIsEnumerable( "a" ); // true
myObject.propertyIsEnumerable( "b" ); // false
Object.keys( myObject ); // ["a"]
Object.getOwnPropertyNames( myObject ); // ["a", "b"]
```

propertyIsEnumerable(..) 会检查给定的属性名是否**直接存在于对象中（而不是在原型链上）**并且满足 enumerable:true。

Object.keys(..) 会返回一个数组，包含所有可枚举属性

Object.getOwnPropertyNames(..) 会返回一个数组，包含所有属性，无论它们是否可枚举

in 和 hasOwnProperty(..) 的区别在于是否查找 [[Prototype]] 链，然而，Object.keys(..) 和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性

### 遍历

> 遍历对 象属性时的顺序是不确定的，在不同的 JavaScript 引擎中可能不一样。因此， 在不同的环境中需要保证一致性时，一定不要相信任何观察到的顺序，它们 是不可靠的

#### for...in与for...of

> `for..in `遍历对象是无法直接获取属性值的，因为它实际上遍历的是对象中的所有可 枚举属性，你需要手动获取属性值
>
> `for..of`可以直接遍历数组的值（**如果对象本身定义了迭代器的话也可以遍历对象**）
>
> `for..of `循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值。

```js
const myArray = [1, 2, 3];
for (key in myArray) {
  console.log(key);
}
console.log("============");
for (value of myArray) {
  console.log(value);
}
/*
    0
    1
    2
    ============
    1
    2
    3
*/
```

#### 数组和对象

数组有内置的 @@iterator，因此 for..of 可以直接应用在数组上。

```js
var myArray = [ 1, 2, 3 ];
var it = myArray[Symbol.iterator]();
it.next(); // { value:1, done:false } 
it.next(); // { value:2, done:false } 
it.next(); // { value:3, done:false } 
it.next(); // { done:true }
```

> @@iterator 本身并不是一个迭代器对象，而是一个返回迭代器对象的函数

普通的对象没有内置的 @@iterator，所以无法自动完成 for..of 遍历。

你可以给任何想遍历的对象定义 @@iterator

```js
const myObject = {
  a: 2,
  b: 3,
};

Object.defineProperty(myObject, Symbol.iterator, {
  enumerable: false,
  writable: false,
  configurable: true,
  value: function () {
    const o = this;
    let idx = 0;
    const ks = Object.keys(o);
    return {
      next: function () {
        return {
          value: o[ks[idx++]],
          done: idx > ks.length,
        };
      },
    };
  },
});
const it = myObject[Symbol.iterator]();
it.next(); // { value:2, done:false } 
it.next(); // { value:3, done:false } 
it.next(); // { value:undefined, done:true }
for (let v of myObject) {
  console.log(v);
}
// 2
// 3
```

## 4.混合对象--类

> **对于真正的类来说，构造函数是属于类的**。然而，在 JavaScript 中恰好相反——实际 上“**类”是属于构造函数的**（类似 `Foo.prototype...` 这样的类型引用）。由于 JavaScript 中父类和子类的关系只存在于两者构造函数对应的 .prototype 对象中，因此**它们的构造函数之间并不存在直接联系，从而无法简单地实现两者的 相对引用（在 ES6 的类中可以通过 super 来“解决”这个问题)**

### 混入

> 在继承或者实例化时，JavaScript 的对象机制并不会自动执行复制行为。简单来说， JavaScript 中只有对象，并不存在可以被实例化的“类”。一个对象并不会被复制到其他对 象，它们会被关联起来

由于在其他语言中类表现出来的都是复制行为，因此 JavaScript 开发者也想出了一个方法来 **模拟类的复制行为，这个方法就是混入**。

#### 总结

类是一种设计模式。许多语言提供了对于面向类软件设计的原生语法。

JavaScript 也有类 似的语法，但是和其他语言中的类完全不同。 

类意味着复制。 

传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。

多态（在继承链的不同层次名称相同但是功能不同的函数）看起来似乎是从子类引用父 类，但是本质上引用的其实是复制的结果。 

JavaScript 并不会（像类那样）自动创建对象的副本。 

混入模式（无论显式还是隐式）可以用来模拟类的复制行为，但是通常会产生丑陋并且脆 弱的语法，比如显式伪多态（`OtherObj.methodName.call(this, ...)`），这会让代码更加难 懂并且难以维护。此外，显式混入实际上无法完全模拟类的复制行为，因为对象（和函数！别忘了函数也 是对象）只能复制引用，无法复制被引用的对象或者函数本身。忽视这一点会导致许多问题。 

总地来说，在 JavaScript 中模拟类是得不偿失的，虽然能解决当前的问题，但是可能会埋下更多的隐患

## 5.原型

### [[Prototype]]

> **JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引用**。
>
> 几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值
>
> (使用`Object.create(null)`创建的对象没有[[Prototype]] 属性)。

![image-20230516195240623](C:\Users\朱豪鹤\AppData\Roaming\Typora\typora-user-images\image-20230516195240623.png)

当你试图引用对象的属性时会触发[[Get]] 操作，比如 myObject.a。对于默认的 [[Get]] 操作来说，第一步是检查对象本身是否有这个属性，如果有的话就使用它。**如果无法在对象本身找到需要的属性，就会继续访问对象的 [[Prototype]] 链：**

```js
const anotherObject = {
	a:2
};
// 创建一个关联到 anotherObject 的对象
const myObject = Object.create( anotherObject );
myObject.a; // 2
```

**这个过程会持续到找到匹配的属性名或者查找完整条 [[Prototype]] 链**。如果是后者的话， [[Get]] 操作的返回值是 `undefined`。

> 使用 for..in 遍历对象时原理和查找 [[Prototype]] 链类似，**任何可以通过原型链访问到 （并且是 `enumerable`）的属性都会被枚举。**使用 **in 操作符来检查属性在对象 中是否存在时，同样会查找对象的整条原型链（无论属性是否可枚举**）

```js
const anotherObject = {
  a: 2,
};
// 创建一个关联到 anotherObject 的对象
const myObject = Object.create(anotherObject);
for (let k in myObject) {
  console.log("found: " + k);
}
// found: a
"a" in myObject; // true
```

#### `Object.prototype`

> 所有普通的 [[Prototype]] 链最终都会指向内置的 `Object.prototype`
>
> 由于所有的“普通” （内置，不是特定主机的扩展）对象都“源于”（或者说把 [[Prototype]] 链的顶端设置为） 这个`Object.prototype` 对象，所以它包含 JavaScript 中许多通用的功能。

对象没有`prototype`属性,构造函数有`prototype`属性, 实例对象的`__proto__`指向创建该对象的构造函数的`prototype`属性

#### 属性设置和屏蔽

给一个对象设置属性并不仅仅是添加一个新属性或者修改已有的属性值

```js
myObject.foo = "bar";
```

- 如果 myObject 对象中包含名为 foo 的普通数据访问属性，这条赋值语句只会修改已有的属 性值

- **如果 foo 不是直接存在于 myObject 中，[[Prototype]] 链就会被遍历，类似 [[Get]] 操作。 如果原型链上找不到 foo，foo 就会被直接添加到 myObject 上。**

- **如果属性名 foo 既出现在 myObject 中也出现在 myObject 的 [[Prototype]] 链上层，那么就会发生屏蔽。**myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为 myObject.foo 总是会**选择原型链中最底层的 foo 属性**。
- 如果 foo 存在于原型链上层, 会有三种情况
  - 如果在 [[Prototype]] 链上层存在名为foo 的普通数据访问属性并且**没有被标记为只读**`writable:true`，那就会直接在 myObject 中添加一个名为 foo 的新属性，它是**屏蔽属性**。
  - 如果在 [[Prototype]] 链上层存在 foo，但是它被**标记为只读**`writable:false`，那么无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，**不会发生屏蔽**。
  - 如果在 [[Prototype]] 链上层存在 foo 并且它是一个 setter，那就一定会 调用这个 setter。foo **不会被添加到（或者说屏蔽于）**myObject，也不会重新定义 foo 这 个 setter。

> 如果你希望在第二种和第三种情况下也屏蔽 foo，那就不能使用 = 操作符来赋值，而是使 用 `Object.defineProperty(..)`来向 `myObject `添加 foo。

**只读属性会阻止 [[Prototype]] 链下层 隐式创建（屏蔽）同名属性。这样做主要是为了模拟类属性的继承**。

你可 以把原型链上层的 foo 看作是父类中的属性，它会被 myObject 继承（复制），这样一来 myObject 中的 foo 属性也是只读，所以无法创建。

但是一定要注意，**实际上并不会发生类似的继承复制**。

这看起来有点奇怪，myObject 对象竟然会因为其他对象中有一个只读 foo 就不 能包含 foo 属性。

更奇怪的是，这个限制只存在于 = 赋值中，**使用 `Object. defineProperty(..)`并不会受到影响**

有些情况下会隐式产生屏蔽:

```js
const anotherObject = {
  a: 2,
};
const myObject = Object.create(anotherObject);
console.log(anotherObject.a); //2
console.log(myObject.a); //2

console.log(anotherObject.hasOwnProperty("a")); //true
console.log(myObject.hasOwnProperty("a")); //false

myObject.a++; //隐式屏蔽！

console.log(anotherObject.a); //2
console.log(myObject.a); //3
```

++ 操作相当于 `myObject.a = myObject.a + 1`。

因此 **++ 操作首先会通过 [[Prototype]] 查找属性 a 并从 anotherObject.a 获取当前属性值 2，然后给这个值加 1，接着用 [[Put]] 将值 3 赋给 myObject 中新建的屏蔽属性 a**，天呐！ 

修改委托属性时一定要小心。如果想让 anotherObject.a 的值增加，唯一的办法是 anotherObject.a++

### "类"

> 在 JavaScript 中，类无法描述对象的行为，（因为根本就不存在类！）对象直接定义自己的行 为。
>
> **JavaScript 中只有对象。**

#### "类"函数

> 所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举的属性，它会指向另一个对象

```js
function Foo() {
// ...
}
Foo.prototype; // { }
```

这个对象是在调用 new Foo()时创建的，最后会被关联到这个`Foo.prototype`对象上。

```js
function Foo() {
	// ...
}
var a = new Foo();
Object.getPrototypeOf( a ) === Foo.prototype; // true
```

**调用 new Foo() 时会创建 a，其中的一步就是给 a 一个内部的 [[Prototype]] 链接，关联到 `Foo.prototype` 指向的那个对象。**

我们并没有初始化一个类，实际上我们并没有从“类”中复制任何行为到一个对象中，只是让两个对象互相关联。

> 在面向类的语言中，类可以被复制（或者说实例化）多次
>
> 实例化（或者继承）一个类就意味着“把类的行为复制到物理对象中”，对于每一个新实例来说都会重复这个过程
>
> **在 JavaScript 中，并没有类似的复制机制。**
>
> 你不能创建一个类的多个实例，只能创建 多个对象，它们 [[Prototype]] 关联的是同一个对象。
>
> 但是在默认情况下并不会进行复制， 因此这些对象之间并不会完全失去联系，它们是互相关联的。

在 JavaScript 中，我们并不会将一个对象（“类”）复制到另一个对象（“实例”），只是将它们 关联起来。

![image-20230517202720166](C:\Users\朱豪鹤\AppData\Roaming\Typora\typora-user-images\image-20230517202720166.png)

这个机制通常被称为**原型继承**，它常常被视为动态语言版本的类继承。

> JavaScript 会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。 ==委托==这个术语可以更加准确地描述 JavaScript 中对象的关联机制。

#### 构造函数

```js
function Foo() {
// ...
}
Foo.prototype.constructor === Foo; // true
const a = new Foo();
a.constructor === Foo; // true
```

`Foo.prototype` 默认有一个公有并且不可枚举的属性 .constructor, 这个属性引用的是对象关联的函数（本例中是 Foo）。

“构造函数”调用 new Foo() 创建的对象也有一个 .constructor 属性，指向 “创建这个对象的函数”。

> 实际上 a 本身并没有 .constructor 属性。而且，虽然 `a.constructor` 确实指 向 Foo 函数，但是这个属性并不是表示 a 由 Foo“构造”

上一段代码很容易让人认为 Foo 是一个构造函数，因为我们使用 new 来调用它并且看到它 “构造”了一个对象。 

实际上，Foo 和你程序中的其他函数没有任何区别。

**函数本身并不是构造函数，然而，当你在普通的函数调用前面加上 new 关键字之后，就会把这个函数调用变成一个“构造函数 调用”。**

实际上，**new 会劫持所有普通函数并用构造对象的形式来调用它**

```js
function NothingSpecial() {
  console.log("Don't mind me!");
}
const b = new NothingSpecial(); // "Don't mind me!"
console.log(b); // {}
```

`NothingSpecial` 只是一个普通的函数，但是使用 new 调用时，它就会构造一个对象并赋值给 a，这看起来像是 new 的一个副作用（无论如何都会构造一个对象）。这个调用是一个构造函数调用，**但是 `NothingSpecial` 本身并不是一个构造函数**

> JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。 
>
> 函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”

```js
function Foo(name) {
	this.name = name;
}
Foo.prototype.myName = function() {
	return this.name;
};
//new操作符将this绑定到新创建的对象中
var a = new Foo( "a" );
var b = new Foo( "b" );
a.myName(); // "a"
b.myName(); // "b"
```

`a.constructor === Foo`中实际上，.constructor 引用同样被委托给了`Foo.prototype`，而` Foo.prototype.constructor` 默认指向 Foo。

```js
function Foo() { /* .. */ }
Foo.prototype = { /* .. */ }; // 创建一个新原型对象
var a1 = new Foo();
a1.constructor === Foo; // false!
a1.constructor === Object; // true!
```

Object(..) 并没有“构造”a1，对吧？看起来应该是 Foo()“构造”了它。大部分开发者 都认为是 Foo() 执行了构造工作，但是问题在于，如果你认为“constructor”表示“由…… 构造”的话，a1.constructor 应该是 Foo，但是它并不是 Foo !

a1 并没有 .constructor 属性，所以它会委托 [[Prototype]] 链上的 Foo. prototype。但是这个对象也没有 .constructor 属性（不过默认的 `Foo.prototype `对象有这 个属性！），所以它会继续委托，这次会委托给委托链顶端的 `Object.prototype`。这个对象 有 .constructor 属性，指向内置的 Object(..) 函数。

> 实际上，对象的 .constructor 会默认指向一个函数，这个函数可以通过对象的 .prototype 引用。“constructor”和“prototype”这两个词本身的含义可能适用也可能不适用。最好的 办法是记住这一点“**constructor 并不表示被构造**”。

### (原型)继承

```js
function Foo(name) {
  this.name = name;
}

Foo.prototype.myName = function () {
  return this.name;
};

function Bar(name, label) {
  Foo.call(this, name);
  this.label = label;
}

Bar.prototype = Object.create(Foo.prototype);
// 注意！现在没有 Bar.prototype.constructor 了
Bar.prototype.myLabel = function () {
  return this.label;
};

const a = new Bar("a", "obj a"); //改变this指向--->新创建的a
console.log(a.myName()); //a
console.log(a.myLabel()); //obj a
```

> `Object.create(..)` 会凭空创建一个“新”对象并把新对象内部的 [[Prototype]] 关联到你 指定的对象（本例中是 `Foo.prototype`）

下面这两种方式是常见的错误做法，实际上它们都存在一些问题:

1. `Bar.prototype = Foo.prototype;`

   **让 `Bar.prototype` 直接引用 `Foo.prototype` 对象**。当你执行类似` Bar.prototype. myLabel = ...` 的赋值语句时会直接修改 `Foo.prototype` 对象本身。

   ```js
   Foo.prototype.myLabel;	//undefined
   Bar.prototype = Foo.prototype;
   Bar.prototype.myLabel = function () {
     return this.label;
   };
   Foo.prototype.myLabel;	//[Function (anonymous)]
   ```

2. `Bar.prototype = new Foo();`

   `Bar.prototype = new Foo()` 的确会创建一个关联到 `Bar.prototype` 的新对象。但是它使用 了 Foo(..) 的“**构造函数调用**”，如果函数 Foo 有一些副作用（比如写日志、修改状态、注册到其他对象、给 this 添加数据属性，等等）的话，就会影响到 Bar() 的“后代”，后果不堪设想。

> 因此，要创建一个合适的关联对象，我们必须使用 `Object.create(..) `而不是使用具有副作用的 Foo(..)。这样做唯一的缺点就是需要**创建一个新对象然后把旧对象抛弃掉**，不能直接修改已有的默认对象

**ES6 添加了辅助函数 `Object.setPrototypeOf(..)`，可以用标准并且可靠的方法来修改关联**。

```js
// ES6 之前需要抛弃默认的 Bar.prototype
Bar.ptototype = Object.create( Foo.prototype );
// ES6 开始可以直接修改现有的 Bar.prototype
Object.setPrototypeOf( Bar.prototype, Foo.prototype );
```

#### 检查"类"关系

> 在传统的面向类环境中，检查一个实例（JavaScript 中的对象）的继承祖先（JavaScript 中的委托关联）通常被称为 内省（或者反射）

`instanceof` 操作符的左操作数是一个普通的对象，右操作数是一个函数。`instanceof `回答的问题是：

==在 a 的整条 [[Prototype]] 链中是否有指向 `Foo.prototype` 的对象==？

**这个方法只能处理对象（a）和函数（带 .prototype 引用的 Foo）之间的关系**。如 果你想判断两个对象（比如 a 和 b）之间是否通过 [[Prototype]] 链关联，只用 `instanceof` 无法实现。

> 如果使用内置的 .bind(..) 函数来生成一个硬绑定函数的话， **该函数是没有 .prototype 属性的**。在这样的函数上使用` instanceof` 的话， 目标函数的 .prototype 会代替硬绑定函数的 .prototype。 通常我们不会在“构造函数调用”中使用硬绑定函数，不过如果你这么做的话，**实际上相当于直接调用目标函数**。同理，**在硬绑定函数上使用 `instanceof `也相当于直接在目标函数上使用 `instanceof`**。

**判断 [[Prototype]] 反射的方法:`Foo.prototype.isPrototypeOf( a );`**

**`isPrototypeOf(..)` 回答的问题是：在 a 的整 条 [[Prototype]] 链中是否出现过 `Foo.prototype` ？**

我们也可以直接获取一个对象的 [[Prototype]] 链:`Object.getPrototypeOf( a );`

浏览器也支持一种非标准的方法来访问内部 [[Prototype]] 属性: `a.__proto__` === `Foo.prototype;`

`.__proto__` 实际上并不存在于你正在使用的对象中 （本例中是 a）。实际上，它和其他的常用函数（`.toString()、.isPrototypeOf(..)`，等等）一样，存在于内置的 `Object.prototype` 中。（它们是不可枚举的） 此外，`.__proto__ `看起来很像一个属性，但是实际上它更像一个 `getter/setter`

`.__proto__` 的实现大致上是这样的

```js
Object.defineProperty( Object.prototype, "__proto__", {
    get: function() {
    	return Object.getPrototypeOf( this );
    },
    set: function(o) {
        // ES6 中的 setPrototypeOf(..)
        Object.setPrototypeOf( this, o );
        return o;
	}
} );
```

访问（获取值）`a.__proto__ `时，实际上是调用了 `a.__proto__()`

**虽然 getter 函数存在于` Object.prototype` 对象中，但是它的 this 指向对象 a**

> 最好把 [[Prototype]] 对象关联看作是只读特性，从而增加代码的可读性。

### 对象关联

#### 创建关联

```js
const foo = {
    something: function() {
    	console.log( "Tell me something good..." );
    }
};
const bar = Object.create( foo );
bar.something(); // Tell me something good..
```

`Object.create(..)` 会创建一个新对象（bar）并把它关联到我们指定的对象（foo），这样 我们就可以充分发挥 [[Prototype]] 机制的威力（委托）并且避免不必要的麻烦（比如**使用 new 的构造函数调用会生成 .prototype 和 .constructor 引用**）

> `Object.create(null)` 会 创 建 一 个 拥 有 空（ 或 者 说 null）[[Prototype]] 链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 `instanceof` 操作符（之前解释过）无法进行判断，因此总是会返回 false。 这些特殊的空 [[Prototype]] 对象通常被称作“字典”，它们完全不会受到原 型链的干扰，因此非常适合用来存储数据。

### 小结

- 如果要访问对象中并不存在的一个属性，[[Get]] 操作就会查找对象内部 [[Prototype]] 关联的对象。这个关联关系实际上定义了一条“原型链”（有点像嵌套的作用域链），在查找属性时会对它进行遍历。 
- 所有普通对象都有内置的 `Object.prototype`，指向原型链的顶端（比如说全局作用域），如果在原型链中找不到指定的属性就会停止。
- `toString()`、`valueOf()` 和其他一些通用的功能 都存在于 `Object.prototype `对象上，因此语言中所有的对象都可以使用它们。
-  关联两个对象最常用的方法是使用 new 关键词进行函数调用，在调用的 4 个步骤中会创建一个关联其他对象的新对象。 **使用 new 调用函数时会把新对象的 .prototype 属性关联到“其他对象”**。带 new 的函数调用 通常被称为“构造函数调用”，尽管它们实际上和传统面向类语言中的类构造函数不一样。
- 虽然这些 JavaScript 机制和传统面向类语言中的“类初始化”和“类继承”很相似，但是 JavaScript 中的机制有一个核心区别，那就是**不会进行复制**，对象之间是通过内部的 [[Prototype]] 链关联的。 
- 出于各种原因，以“继承”结尾的术语（包括“原型继承”）和其他面向对象的术语都无法帮助你理解 JavaScript 的真实机制（不仅仅是限制我们的思维模式）。 
- 相比之下，“委托”是一个更合适的术语，因为对象之间的关系不是复制而是委托。

## 6.行为委托

### 委托理论

```js
Task = {
    setID: function(ID) { this.id = ID; },
    outputID: function() { console.log( this.id ); }
};
// 让 XYZ 委托 Task
XYZ = Object.create( Task );
XYZ.prepareTask = function(ID,Label) {
    this.setID( ID );
    this.label = Label;
};
XYZ.outputTaskDetails = function() {
    this.outputID();
    console.log( this.label );
};
// ABC = Object.create( Task );
// ABC ... = ...
```

1. 在上面的代码中，id 和 label 数据成员都是直接存储在 XYZ 上（而不是 Task）。通常来说，在 [[Prototype]] 委托中最好**把状态保存在委托者（XYZ、ABC）而不是委托目标（Task）上**。 
2. 在类设计模式中，我们故意让父类（Task）和子类（XYZ）中都有 outputTask 方法，这样就可以利用重写（多态）的优势。在委托行为中则恰好相反：我们会尽量避免在 [[Prototype]] 链的不同级别中使用相同的命名，否则就需要使用笨拙并且脆弱的语法来消除引用歧义。 这个设计模式要求**尽量少使用容易被重写的通用方法名，提倡使用更有描述性的方法名，尤其是要写清相应对象行为的类型。**这样做实际上可以创建出更容易理解和维护的 代码，因为方法名（不仅在定义的位置，而是贯穿整个代码）更加清晰（自文档）。 
3. this.setID(ID)；XYZ 中的方法首先会寻找 XYZ 自身是否有 setID(..)，但是 XYZ 中并没 有这个方法名，因此会通过 [[Prototype]] 委托关联到 Task 继续寻找，这时就可以找到 setID(..) 方法。此外，由于调用位置**触发了 this 的隐式绑定规则**，因此虽然 setID(..) 方法在 Task 中，运行时 this 仍然会绑定到 XYZ，这正是我们想要的。 在之后的代码中我们还会看到 this.outputID()，原理相同。 换句话说，我们和 XYZ 进行交互时可以使用 Task 中的通用方法，因为 XYZ 委托了 Task。 委托行为意味着某些对象（XYZ）在找不到属性或者方法引用时会把这个请求委托给另一个对象（Task）

> 委托行为意味着某些对象（XYZ）在找不到属性或者方法引用时会把这个请求委托给另一个对象（Task）
>
> **在 API 接口的设计中，委托最好在内部实现，不要直接暴露出去**。在之前的 例子中我们并没有让开发者通过 API 直接调用 XYZ.setID()。（当然，可以这 么做！）相反，我们把委托隐藏在了 API 的内部，XYZ.prepareTask(..) 会 委托 Task.setID(..)。

#### 互相委托

> 你无法在两个或两个以上互相（双向）委托的对象之间创建循环委托。如果你把 B 关联到 A 然后试着把 A 关联到 B，就会出错。

如果你引用了一个 两边都不存在的属性或者方法，那就会在 [[Prototype]] 链上产生一个无限递归的循环。

之所以要禁止互相委托，是因为引擎的开发者们发现在设置时检查（并禁止！）一次无限循环引用要更加高效，否则每次从对象中查找属性时都需要进行检查

#### 调试

> 浏览器和工具的解析结果**并不一定相同**

**FireFox**

![image-20230521162533042](C:\Users\朱豪鹤\AppData\Roaming\Typora\typora-user-images\image-20230521162533042.png)

**Chrome**

![image-20230521162600201](C:\Users\朱豪鹤\AppData\Roaming\Typora\typora-user-images\image-20230521162600201.png)

Chrome 实际上想说的是“{} 是一个空对象，由名为 Foo 的函数构造”。Firefox 想说的是“{} 是一个空对象，由 Object 构造”。之所以有这种细微的差别，是因为 **Chrome 会动态跟踪并把实际执行构造过程的函数名当作一个内置属性，但是其他浏览器并不会跟踪这些额外的信息**。

如果你并不是使用“构造函数”来生成对象，比如使用对象关联风格来编写代 码，那 Chrome 就无法跟踪对象内部的“构造函数名称”

![image-20230521163026145](C:\Users\朱豪鹤\AppData\Roaming\Typora\typora-user-images\image-20230521163026145.png)

### 对比

#### 面向对象风格

```js
function Foo(who) {
	this.me = who;
}
Foo.prototype.identify = function() {
	return "I am " + this.me;
};
function Bar(who) {
	Foo.call( this, who );
}
Bar.prototype = Object.create( Foo.prototype );
Bar.prototype.speak = function() {
	alert( "Hello, " + this.identify() + "." );
};
var b1 = new Bar( "b1" );
var b2 = new Bar( "b2" );
b1.speak();
b2.speak();
```

子类 Bar 继承了父类 Foo，然后生成了 b1 和 b2 两个实例。**b1 委托了 Bar.prototype，Bar.prototype委托了 Foo.prototype**。

#### 对象关联风格

```js
Foo = {
	init: function(who) {
    	this.me = who;
	},
	identify: function() {
		return "I am " + this.me;
	}
};
Bar = Object.create( Foo );
Bar.speak = function() {
	alert( "Hello, " + this.identify() + "." );
};
var b1 = Object.create( Bar );
b1.init( "b1" );
var b2 = Object.create( Bar );
b2.init( "b2" );
b1.speak();
b2.speak();
```

这段代码中我们同样**利用 [[Prototype]] 把 b1 委托给 Bar 并把 Bar 委托给 Foo**，和上一段 代码一模一样。我们仍然实现了三个对象之间的关联。

> 这段代码简洁了许多，我们只是把对象关联起来，并不需要那些 既复杂又令人困惑的模仿类的行为（构造函数、原型以及 new）。

#### 思维模型

> 类风格代码的思维模型**强调实体以及实体间的关系**

![image-20230521164237448](C:\Users\朱豪鹤\AppData\Roaming\Typora\typora-user-images\image-20230521164237448.png)

JavaScript中的函数之所以可以访问 call(..)、apply(..) 和 bind(..)，就是因为**函数本身是对象**。而函数对象同样有 [[Prototype]]属性并且关 联到 Function.prototype 对象，因此所有函数对象都可以通过委托调用这些默认方法。

简化一下:

![image-20230521164607217](C:\Users\朱豪鹤\AppData\Roaming\Typora\typora-user-images\image-20230521164607217.png)

> 对象关联风格的代码更加简洁，因为这种代码只关注一件事：**对象之间的关联关系**。 其他的“类”技巧都是非常复杂并且令人困惑的。去掉它们之后，事情会变得简单许多 （同时保留所有功能）。

![image-20230521164732928](C:\Users\朱豪鹤\AppData\Roaming\Typora\typora-user-images\image-20230521164732928.png)

### 类与对象

#### 控件"类"

```js
class Widget {
  constructor(width, height) {
    this.width = width || 50;
    this.height = height || 50;
    this.$elem = null;
  }
  render($where) {
    if (this.$elem) {
      this.$elem
        .css({
          width: this.width + "px",
          height: this.height + "px",
        })
        .appendTo($where);
    }
  }
}
class Button extends Widget {
  constructor(width, height, label) {
    super(width, height);
    this.label = label || "Default";
    this.$elem = $("<button>").text(this.label);
  }
  render($where) {
    super($where);
    this.$elem.click(this.onClick.bind(this));
  }
  onClick(evt) {
    console.log("Button '" + this.label + "' clicked!");
  }
}

$(document).ready(function () {
  var $body = $(document.body);
  var btn1 = new Button(125, 30, "Hello");
  var btn2 = new Button(150, 40, "World");
  btn1.render($body);
  btn2.render($body);
});

```

#### 控件对象

```js
var Widget = {
  init: function (width, height) {
    this.width = width || 50;
    this.height = height || 50;
    this.$elem = null;
  },
  insert: function ($where) {
    if (this.$elem) {
      this.$elem
        .css({
          width: this.width + "px",
          height: this.height + "px",
        })
        .appendTo($where);
    }
  },
};
var Button = Object.create(Widget);
Button.setup = function (width, height, label) {
  // 委托调用
  this.init(width, height);
  this.label = label || "Default";
  this.$elem = $("<button>").text(this.label);
};
Button.build = function ($where) {
  // 委托调用
  this.insert($where);
  this.$elem.click(this.onClick.bind(this));
};
Button.onClick = function (evt) {
  console.log("Button '" + this.label + "' clicked!");
};
$(document).ready(function () {
  var $body = $(document.body);
  var btn1 = Object.create(Button);
  btn1.setup(125, 30, "Hello");
  var btn2 = Object.create(Button);
  btn2.setup(150, 40, "World");
  btn1.build($body);
  btn2.build($body);
});
```

#### 对比

> 使用对象关联风格来编写代码时不需要把 Widget 和 Button 当作父类和子类。
>
> 从设计模式的角度来说，我们并没有像类一样在两个对象中都定义相同的方法名 render(..)，相反，我们定义了两个更具描述性的方法名（insert(..) 和 build(..)）。同理，初始化方法分别叫作 init(..) 和 setup(..)
>
> 从语法角度来说，我们同样没有使用任何构造函数、.prototype 或 new
>
> 使用类构造函数的话，你需要（并不是硬性要求，但是强烈建议）在同一个步骤中实现构造和初始化。然而，在许多情况下把这两步分开（就像对象关联代码一样）更灵活。
>
> **对象关联可以更好地支持关注分离（separation of concerns）原则**，创建和初始化并不需要 合并为一个步骤

### 更好的语法

> ES6 中 我 们 可 以 在 任 意 对 象 的 字 面 形 式 中 使 用 简 洁 方 法 声 明

```js
var LoginController = {
    errors: [],
    getUser() { // 妈妈再也不用担心代码里有 function 了！
    	// ...
    },
    getPassword() {
    	// ...
    }
   	 // ...
};
var AuthController = {
   errors: [],
   checkAuth() {
    	// ...
    },
   server(url,data) {
    	// ...
    }
    // ...
};
// 现在把 AuthController 关联到 LoginController
Object.setPrototypeOf( AuthController, LoginController )
```

使用 ES6 的简洁方法可以让对象关联风格更加人性化（并且仍然比典型的原型风格代码更 加简洁和优秀）。你完全不需要使用类就能享受整洁的对象语法

#### 缺点

简洁方法有一个非常小但是非常重要的缺点。

```js
var Foo = {
	bar() { /*..*/ },
	baz: function baz() { /*..*/ }
};
```

去掉语法糖之后的代码如下所示

```js
var Foo = {
    bar: function() { /*..*/ },
    baz: function baz() { /*..*/ }
};
```

函 数 对 象 本 身 没 有 名 称 标 识 符， 所 以 bar() 的 缩 写 形 式 （function()..）实际上会变成一个匿名函数表达式并赋值给 bar 属性。

相比之下，具名函数表达式（function baz()..）会额外给 .baz 属性附加一个词法名称标识符 baz。

匿名函数没有 name 标识符，这会导致： 

1. 调试栈更难追踪； 
2. 自我引用（递归、事件（解除）绑定，等等）更难； 
3. 代码（稍微）更难理解。 

简洁方法没有第 1 和第 3 个缺点。

> 去掉语法糖的版本使用的是匿名函数表达式，通常来说并不会在追踪栈中添加 name，但是**简洁方法很特殊，会给对应的函数对象设置一个内部的 name 属性**，这样理论上可以用在追踪栈中。

很不幸，简洁方法无法避免第 2 个缺点，它们**不具备可以自我引用的词法标识符**。

```js
var Foo = {
	bar: function(x) {
		if(x<10){
			return Foo.bar( x * 2 );
		}
		return x;
	},
    baz: function baz(x) {
    	if(x < 10){
    		return baz( x * 2 );
    	}
    	return x;
    }
};
```

本例中使用 Foo.bar(x*2) 就足够了，但是在许多情况下无法使用这种方法，比如多个对象通过代理共享函数、使用 this 绑定，等等。这种情况下最好的办法就是**使用函数对象的 name 标识符来进行真正的自我引用**。

> 使用简洁方法时一定要小心这一点。如果你需要自我引用的话，那最好使用传统的具名函 数表达式来定义对应的函数（ · baz: function baz(){..}· ），不要使用简洁方法。
